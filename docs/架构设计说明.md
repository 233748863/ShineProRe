# 技能循环引擎 - 架构设计说明

## 架构概述

本项目采用现代化的软件架构设计，基于**依赖注入**和**策略模式**，实现了高度模块化、可扩展、安全可靠的技能循环引擎。

## 架构层次

### 1. 接口层 (Interface Layer)
```
interface/
├── 按键操作接口.py    # 按键操作抽象
├── 图像获取接口.py    # 图像获取抽象
└── 事件监听接口.py    # 事件监听抽象
```

**设计原则**：
- 接口隔离原则：每个接口职责单一
- 依赖倒置原则：高层模块不依赖低层模块
- 开闭原则：对扩展开放，对修改关闭

### 2. 核心层 (Core Layer)
```
core/
├── 依赖容器.py        # 依赖注入容器
├── 策略接口.py        # 策略模式接口
├── 技能状态检测器.py  # 状态检测逻辑
└── 技能决策引擎.py    # 决策算法实现
```

**设计模式**：
- 依赖注入模式：解耦组件依赖
- 策略模式：支持运行时算法切换
- 工厂模式：对象创建封装

### 3. 工具层 (Utils Layer)
```
utils/
├── 性能监控.py        # 性能统计和监控
├── 异常隔离.py        # 统一异常处理机制
├── 权限控制.py        # 权限和频率控制
├── 配置监听器.py      # 配置热重载
├── 日志管理.py        # 分级日志系统
├── 调试工具.py        # 调试支持工具
├── 统一缓存管理器.py  # 缓存管理系统
├── 时间戳优化器.py    # 性能优化工具
├── 异步处理.py        # 异步处理工具
└── 图像缓存.py        # 图像缓存管理
```

## 核心设计模式

### 依赖注入 (Dependency Injection)

```python
# 容器工厂创建默认容器
容器 = 容器工厂.创建默认容器(配置路径)

# 获取依赖实例
按键接口 = 容器.获取实例(按键操作接口)
图像接口 = 容器.获取实例(图像获取接口)
```

**优势**：
- 降低耦合度
- 提高可测试性
- 支持配置化依赖管理

### 策略模式 (Strategy Pattern)

```python
# 策略管理器
策略管理器 = 策略管理器()

# 运行时策略切换
策略管理器.设置当前策略(循环模式.PVE模式)

# 策略执行
技能键值 = 策略.推算技能(策略上下文)
```

**支持的策略**：
- 默认循环策略
- 驱散循环策略
- PVE模式策略
- PVP模式策略
- 竞速模式策略

### 装饰器模式 (Decorator Pattern)

```python
@需要权限("技能释放")
@监控操作("执行技能循环")
@安全执行技能检测
def 执行一次循环(self) -> bool:
    # 业务逻辑
    pass
```

**功能装饰器**：
- 权限检查装饰器
- 性能监控装饰器
- 异常隔离装饰器
- 安全执行装饰器

## 数据流设计

### 配置数据流
```
配置文件 → 配置监听器 → 配置管理器 → 依赖容器 → 业务组件
```

### 执行数据流
```
权限检查 → 性能监控 → 异常隔离 → 策略决策 → 按键执行 → 结果统计
```

### 日志数据流
```
日志记录 → 日志管理器 → 文件输出/控制台输出 → 日志统计
```

## 安全设计（增强版）

### 1. 权限控制
- 系统权限检查（管理员、屏幕访问、输入设备）
- 操作频率限制（防止过度使用）
- 权限装饰器（方法级权限控制）

### 2. 统一异常处理
- **异常分类系统**：配置异常、权限异常、执行异常、系统异常
- **统一异常处理器**：集中管理所有异常处理逻辑
- **智能重试机制**：根据异常类型自动重试策略
- **异常统计报告**：详细的异常类型和频率分析
- **安全执行模式**：所有操作都经过异常隔离

### 3. 性能监控（增强）
- **时间戳优化器**：减少系统调用开销
- **统一缓存管理**：多级缓存策略
- **滑动窗口统计**：O(1)复杂度的实时统计
- **性能报告生成**：详细的性能指标和优化建议
- **资源使用监控**：内存、CPU、网络等资源监控

### 4. 环境配置管理
- **环境检测机制**：自动识别开发/生产环境
- **配置继承机制**：基础配置 + 环境特定配置
- **配置验证系统**：自动验证配置格式和完整性
- **配置备份恢复**：配置版本控制和回滚机制
- **配置变更回调**：配置变更时的回调机制

## 扩展性设计

### 1. 插件化架构
```python
def 注册新策略(self, 策略实例):
    """注册新的策略实现"""
    self.策略管理器.注册策略(策略实例)
```

### 2. 配置驱动
- 所有行为均可通过配置文件调整
- 支持热重载配置
- 配置验证和错误处理

### 3. 接口抽象
- 清晰的接口定义
- 支持多种实现替换
- 易于集成和测试

## 性能优化

### 1. 缓存机制
- 图像缓存（避免重复截图）
- 配置缓存（减少文件读取）
- 单例模式（减少对象创建）

### 2. 异步处理
- 非阻塞操作
- 线程池管理
- 性能监控集成

### 3. 资源管理
- 自动资源释放
- 内存使用优化
- 文件句柄管理

## 测试策略

### 1. 单元测试
- 接口测试
- 策略测试
- 工具类测试

### 2. 集成测试
- 组件集成测试
- 端到端测试
- 性能测试

### 3. 模拟测试
- 模拟按键操作
- 模拟图像获取
- 异常场景测试

## 部署架构

### 1. 依赖管理
```
pip install -r requirements.txt
```

### 2. 配置管理
- 环境特定的配置
- 敏感信息加密
- 配置版本控制

### 3. 监控部署
- 日志文件管理
- 性能监控部署
- 错误报警机制

## 技术选型理由

### 选择Python的原因：
- 快速开发迭代
- 丰富的图像处理库
- 跨平台兼容性
- 强大的社区支持

### 架构设计优势：
- **可维护性**：清晰的模块划分
- **可扩展性**：插件化设计
- **可靠性**：完善的错误处理
- **性能**：优化的资源管理

## 未来扩展方向

### 1. 机器学习集成
- 基于深度学习的技能识别
- 自适应策略调整
- 智能性能优化

### 2. 云服务支持
- 配置云同步
- 远程监控
- 数据分析服务

### 3. 多平台支持
- 移动端适配
- 跨游戏引擎
- 国际化支持

---

## 总结

本架构设计遵循现代软件工程最佳实践，通过**依赖注入**、**策略模式**、**装饰器模式**等设计模式，实现了高度模块化、可扩展、安全可靠的技能循环引擎。架构设计充分考虑到了性能、可维护性、可测试性等关键因素，为项目的长期发展奠定了坚实基础。
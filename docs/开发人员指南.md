# 技能循环引擎 - 开发人员指南

## 开发环境设置

### 1. 环境要求
```bash
# Python版本
Python >= 3.8

# 核心依赖
opencv-python >= 4.5.0
pynput >= 1.7.0
watchdog >= 2.0.0

# 新增依赖（用于增强功能）
numpy >= 1.21.0
Pillow >= 8.3.0
```

### 2. 开发环境安装
```bash
# 克隆项目
git clone <repository-url>
cd ShineProRe

# 安装开发依赖
pip install -r requirements-dev.txt

# 安装预提交钩子
pre-commit install
```

### 3. 开发工具配置

**推荐IDE配置**：
- VS Code with Python extension
- PyCharm Professional
- 安装必要的代码格式化工具

**环境变量设置**：
```bash
# 设置开发环境
export SHINE_ENV=development

# 设置调试模式
export SHINE_DEBUG=true

# 设置日志级别
export SHINE_LOG_LEVEL=debug
```

## 代码规范

### 1. 命名规范

**文件命名**：
- 使用中文描述性名称
- 避免特殊字符和空格
- 示例：`技能循环引擎.py`、`配置管理器.py`

**类命名**：
- 使用大驼峰命名法
- 示例：`技能循环引擎`、`配置管理器`

**方法命名**：
- 使用动词+名词的格式
- 示例：`执行一次循环()`、`获取性能报告()`

**变量命名**：
- 使用描述性名称
- 避免使用单字母变量
- 示例：`技能键值`、`检测区域`

### 2. 代码风格

**缩进和空格**：
```python
# 正确：使用4个空格缩进
def 示例方法(self, 参数1, 参数2):
    变量 = 计算表达式()
    return 结果

# 错误：使用制表符或2个空格
```

**行长度**：
- 每行不超过100个字符
- 使用括号或反斜杠进行换行

**导入顺序**：
```python
# 标准库导入
import os
import sys
from typing import Dict, Any

# 第三方库导入
import cv2
from pynput import keyboard
import numpy as np

# 本地模块导入
from core.策略接口 import 策略管理器
from utils.性能监控 import 性能监控器
from utils.异常隔离 import 统一异常处理器
from config.配置管理器 import 配置管理器
```

### 3. 文档字符串

**模块文档**：
```python
"""
模块名称 - 模块功能描述

详细描述模块的功能、使用方法和注意事项
"""
```

**类文档**：
```python
class 示例类:
    """
    类功能描述
    
    属性:
        属性1: 属性描述
        属性2: 属性描述
    
    方法:
        方法1: 方法描述
        方法2: 方法描述
    """
```

**方法文档**：
```python
def 示例方法(self, 参数1: int, 参数2: str) -> bool:
    """
    方法功能描述
    
    参数:
        参数1: 参数描述
        参数2: 参数描述
    
    返回:
        bool: 返回结果描述
    
    异常:
        ValueError: 参数错误时抛出
    """
```

## 开发流程（增强版）

### 1. 功能开发流程

**步骤1：需求分析**
- 明确功能需求
- 设计接口定义
- 制定测试计划
- **新增**: 异常处理策略设计
- **新增**: 性能优化考虑
- **新增**: 环境配置支持

**步骤2：接口设计**
```python
# 在interface/目录下创建接口文件
from abc import ABC, abstractmethod
from typing import Any, Optional

class 新功能接口(ABC):
    @abstractmethod
    def 新方法(self, 参数) -> 返回类型:
        """方法功能描述
        
        异常:
            异常类型: 异常描述
        """
        pass
    
    @abstractmethod
    def 安全执行方法(self, 参数) -> tuple[bool, Optional[Any], str]:
        """安全执行方法，返回(成功, 结果, 错误信息)"""
        pass
```

**步骤3：实现开发**
- 在core/或utils/目录下实现功能
- 遵循依赖注入原则
- **新增**: 集成统一异常处理
- **新增**: 添加性能监控
- **新增**: 支持环境配置
- 添加单元测试

**步骤4：集成测试**
- 测试新功能与现有系统的集成
- 验证性能影响
- 检查错误处理
- **新增**: 异常处理测试
- **新增**: 环境配置测试
- **新增**: 性能基准测试

### 2. 代码审查要点

**架构审查**：
- 是否符合依赖注入原则
- 是否遵循策略模式设计
- 是否有不必要的耦合

**代码质量**：
- 代码可读性
- 错误处理完整性
- 性能考虑

**测试覆盖**：
- 单元测试覆盖度
- 集成测试覆盖度
- 边界条件测试

## 核心组件开发指南

### 1. 开发新策略

**创建策略类**：
```python
from core.策略接口 import 抽象策略, 循环模式

class 新策略(抽象策略):
    def __init__(self):
        super().__init__(
            策略名称="新策略",
            策略描述="新策略功能描述",
            支持模式=[循环模式.PVE模式, 循环模式.PVP模式]
        )
    
    def 推算技能(self, 上下文: 策略上下文) -> int:
        """新策略的推算逻辑"""
        # 实现具体的策略逻辑
        return 技能键值
```

**注册策略**：
```python
# 在引擎初始化时注册新策略
新策略实例 = 新策略()
引擎.注册新策略(新策略实例)
```

### 2. 开发新工具类（增强版）

**创建工具类**：
```python
from typing import Dict, Any, Optional
from utils.异常隔离 import 统一异常处理器
from utils.性能监控 import 性能监控器

class 新工具类:
    """新工具类功能描述"""
    
    def __init__(self, 配置参数: Dict[str, Any]):
        self.配置参数 = 配置参数
        self.异常处理器 = 统一异常处理器()
        self.性能监控器 = 性能监控器()
        self.初始化工具()
    
    def 初始化工具(self):
        """工具初始化逻辑"""
        # 使用安全执行初始化
        成功, _, 错误 = self.异常处理器.安全执行(self._实际初始化)
        if not 成功:
            raise RuntimeError(f"工具初始化失败: {错误}")
    
    def _实际初始化(self):
        """实际的初始化逻辑"""
        pass
    
    def 工具方法(self, 输入参数) -> 输出类型:
        """工具方法功能描述"""
        # 使用性能监控
        with self.性能监控器.监控操作("工具方法"):
            # 使用安全执行
            成功, 结果, 错误 = self.异常处理器.安全执行(self._实际工具方法, 输入参数)
            if not 成功:
                raise RuntimeError(f"工具方法执行失败: {错误}")
            return 结果
    
    def _实际工具方法(self, 输入参数) -> 输出类型:
        """实际的工具方法逻辑"""
        # 实现工具逻辑
        return 输出结果
    
    def 安全工具方法(self, 输入参数) -> tuple[bool, Optional[输出类型], str]:
        """安全版本的工具方法"""
        return self.异常处理器.安全执行(self._实际工具方法, 输入参数)
```

**集成到依赖容器**：
```python
# 在容器工厂中注册
容器.注册工厂(新工具接口, lambda: 新工具类(配置参数))

# 或者使用环境特定的配置
容器.注册工厂(新工具接口, lambda: 新工具类(配置管理器.获取环境配置("development")))
```

### 3. 开发新接口适配器（增强版）

**创建适配器**：
```python
from interface.按键操作接口 import 按键操作接口
from typing import Dict, Any
from utils.异常隔离 import 统一异常处理器
from utils.性能监控 import 性能监控器

class 新按键适配器(按键操作接口):
    """新的按键操作适配器实现"""
    
    def __init__(self, 适配器配置: Dict[str, Any]):
        self.配置 = 适配器配置
        self.异常处理器 = 统一异常处理器()
        self.性能监控器 = 性能监控器()
        self.初始化适配器()
    
    def 初始化适配器(self):
        """适配器初始化逻辑"""
        # 安全初始化
        成功, _, 错误 = self.异常处理器.安全执行(self._实际初始化适配器)
        if not 成功:
            raise RuntimeError(f"适配器初始化失败: {错误}")
    
    def _实际初始化适配器(self):
        """实际的适配器初始化逻辑"""
        pass
    
    def 按下并释放(self, 键值: int) -> bool:
        """按下并释放按键的实现"""
        # 使用性能监控和异常处理
        with self.性能监控器.监控操作("按键操作"):
            成功, 结果, 错误 = self.异常处理器.安全执行(self._实际按下并释放, 键值)
            if not 成功:
                # 记录异常但不抛出，保持系统稳定
                self.异常处理器.记录异常("按键操作异常", 错误)
                return False
            return 结果
    
    def _实际按下并释放(self, 键值: int) -> bool:
        """实际的按键操作逻辑"""
        # 实现具体的按键逻辑
        return True
    
    def 安全按下并释放(self, 键值: int) -> tuple[bool, bool, str]:
        """安全版本的按键操作"""
        return self.异常处理器.安全执行(self._实际按下并释放, 键值)
```

## 测试开发指南

### 1. 单元测试编写

**测试文件结构**：
```
tests/
├── unit/
│   ├── test_技能状态检测器.py
│   ├── test_策略接口.py
│   └── test_性能监控.py
└── integration/
    ├── test_引擎集成.py
    └── test_配置管理.py
```

**测试示例**：
```python
import unittest
from unittest.mock import Mock, patch
from core.技能状态检测器 import 技能状态检测器

class Test技能状态检测器(unittest.TestCase):
    
    def setUp(self):
        """测试前置设置"""
        self.检测器 = 技能状态检测器()
        self.模拟图像 = Mock()
    
    def test_判断技能可用性(self):
        """测试技能可用性判断"""
        # 设置模拟数据
        技能配置 = {"颜色": [255, 255, 255], "坐标": [100, 100]}
        self.模拟图像.getpixel.return_value = (255, 255, 255)
        
        # 执行测试
        结果 = self.检测器.判断普通技能可用性(self.模拟图像, 技能配置)
        
        # 验证结果
        self.assertEqual(结果, 1)
    
    def test_判断技能不可用(self):
        """测试技能不可用情况"""
        技能配置 = {"颜色": [255, 255, 255], "坐标": [100, 100]}
        self.模拟图像.getpixel.return_value = (0, 0, 0)
        
        结果 = self.检测器.判断普通技能可用性(self.模拟图像, 技能配置)
        
        self.assertEqual(结果, 0)

if __name__ == '__main__':
    unittest.main()
```

### 2. 集成测试编写

**集成测试示例**：
```python
import unittest
from 技能循环引擎 import 技能循环引擎
from interface.按键操作接口 import 按键操作接口
from interface.图像获取接口 import 图像获取接口

class Test引擎集成(unittest.TestCase):
    
    def test_引擎初始化(self):
        """测试引擎初始化过程"""
        # 创建模拟适配器
        模拟按键适配器 = Mock(spec=按键操作接口)
        模拟图像适配器 = Mock(spec=图像获取接口)
        
        # 创建引擎实例
        引擎 = 技能循环引擎(
            配置路径="./config/",
            按键接口=模拟按键适配器,
            图像接口=模拟图像适配器
        )
        
        # 验证引擎状态
        self.assertIsNotNone(引擎)
        self.assertTrue(引擎.使用智能模式)
```

## 调试和性能优化

### 1. 调试工具使用

**启用调试模式**：
```python
# 设置日志级别为调试
引擎.设置日志级别("调试")

# 启用性能监控
性能报告 = 引擎.获取性能报告()
print(性能报告)
```

**使用调试工具**：
```python
from utils.调试工具 import 调试工具

# 创建调试工具实例
调试器 = 调试工具()

# 显示检测区域
调试器.显示检测区域(检测区域, 屏幕图像)
```

### 2. 性能优化技巧

**图像处理优化**：
```python
# 使用图像缓存避免重复截图
class 优化图像获取器(图像获取接口):
    def __init__(self):
        self.图像缓存 = {}
        self.缓存时间 = {}
        self.缓存有效期 = 0.1  # 100毫秒
    
    def 获取屏幕区域(self, 区域: tuple):
        import time
        当前时间 = time.time()
        
        # 检查缓存
        if 区域 in self.图像缓存:
            if 当前时间 - self.缓存时间[区域] < self.缓存有效期:
                return self.图像缓存[区域]
        
        # 获取新图像并缓存
        新图像 = self.实际获取图像(区域)
        self.图像缓存[区域] = 新图像
        self.缓存时间[区域] = 当前时间
        
        return 新图像
```

**内存使用优化**：
```python
# 及时释放大对象
class 内存优化类:
    def 处理大对象(self):
        大对象 = self.获取大对象()
        try:
            # 处理大对象
            结果 = self.处理逻辑(大对象)
            return 结果
        finally:
            # 确保释放资源
            del 大对象
```

## 版本控制和发布

### 1. Git工作流

**分支策略**：
- `main`：稳定版本分支
- `develop`：开发分支
- `feature/xxx`：功能分支
- `hotfix/xxx`：热修复分支

**提交规范**：
```bash
# 功能提交
feat: 添加新的策略模式

# 修复提交
fix: 修复技能检测逻辑错误

# 文档提交
docs: 更新开发人员指南

# 重构提交
refactor: 优化依赖注入容器
```

### 2. 版本发布

**版本号规范**：
- 主版本号.次版本号.修订版本号
- 示例：v1.2.3

**发布检查清单**：
- [ ] 所有测试通过
- [ ] 文档更新完成
- [ ] 性能测试完成
- [ ] 兼容性验证完成
- [ ] 发布说明编写完成

## 常见问题解决

### 1. 依赖问题

**问题**：模块导入错误
**解决**：检查依赖容器配置，确保接口映射正确

**问题**：循环依赖
**解决**：使用依赖注入解耦，避免直接导入

### 2. 性能问题

**问题**：内存泄漏
**解决**：使用内存分析工具，检查对象引用

**问题**：CPU使用率高
**解决**：优化图像处理逻辑，增加缓存机制

### 3. 配置问题

**问题**：配置热重载不生效
**解决**：检查文件监听器配置，验证文件权限

**问题**：配置格式错误
**解决**：添加配置验证逻辑，提供详细错误信息

---

## 贡献指南

### 1. 提交代码
- 遵循代码规范
- 添加必要的测试
- 更新相关文档
- 通过代码审查

### 2. 报告问题
- 提供详细的问题描述
- 包含复现步骤
- 提供日志和配置信息

### 3. 功能建议
- 描述功能需求
- 提供使用场景
- 讨论技术可行性

通过遵循本指南，您可以高效地参与项目开发，确保代码质量和项目稳定性。
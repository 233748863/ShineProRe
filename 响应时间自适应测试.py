#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
响应时间自适应调整功能测试
验证智能动态优化机制是否正常工作
"""

import time
import random

# 模拟技能循环引擎的响应时间自适应调整功能
class 响应时间自适应测试器:
    """测试响应时间自适应调整功能"""
    
    def __init__(self):
        # 响应时间优化相关
        self._响应时间阈值 = 0.1  # 100ms阈值
        self._连续超时次数 = 0
        self._自适应调整间隔 = 10  # 每10次执行检查一次
        
        # 性能统计
        self.性能统计 = {
            "总执行时间": 0.0,
            "平均响应时间": 0.0,
            "成功率": 0.0,
            "最小响应时间": float('inf'),
            "最大响应时间": 0.0,
            "响应时间分布": []  # 记录最近100次响应时间
        }
        
        self.执行次数 = 0
        
    def 模拟执行循环(self, 响应时间: float = None) -> bool:
        """模拟执行一次技能循环"""
        if 响应时间 is None:
            # 生成随机响应时间（50ms-300ms）
            响应时间 = random.uniform(0.05, 0.3)
        
        # 模拟执行耗时
        time.sleep(响应时间)
        
        # 更新性能统计
        self.执行次数 += 1
        self.性能统计["总执行时间"] += 响应时间
        
        # 记录响应时间分布
        if len(self.性能统计["响应时间分布"]) >= 100:
            self.性能统计["响应时间分布"].pop(0)
        self.性能统计["响应时间分布"].append(响应时间)
        
        # 更新最小最大响应时间
        self.性能统计["最小响应时间"] = min(self.性能统计["最小响应时间"], 响应时间)
        self.性能统计["最大响应时间"] = max(self.性能统计["最大响应时间"], 响应时间)
        
        # 每20次更新平均响应时间
        if self.执行次数 % 20 == 0:
            self.性能统计["平均响应时间"] = self.性能统计["总执行时间"] / self.执行次数
            self.性能统计["成功率"] = (self.执行次数 - 0) / self.执行次数
        
        # 执行响应时间优化
        if 响应时间 > self._响应时间阈值 * 0.8:
            self._优化响应时间(响应时间)
        
        return True
    
    def _优化响应时间(self, 执行时间: float):
        """响应时间优化逻辑"""
        # 减少响应时间分布记录频率
        if self.执行次数 % 5 == 0:
            if len(self.性能统计["响应时间分布"]) >= 100:
                self.性能统计["响应时间分布"].pop(0)
            self.性能统计["响应时间分布"].append(执行时间)
        
        # 检查是否超时
        if 执行时间 > self._响应时间阈值:
            self._连续超时次数 += 1
            
            # 连续超时过多时进行自适应调整
            if self._连续超时次数 >= 3:
                self._执行响应时间优化策略()
                self._连续超时次数 = 0
        else:
            self._连续超时次数 = 0
        
        # 定期性能优化
        if self.执行次数 % (self._自适应调整间隔 * 2) == 0:
            self._定期性能优化()
    
    def _执行响应时间优化策略(self):
        """执行响应时间优化策略"""
        print(f"检测到响应时间过慢，执行智能优化策略 (阈值: {self._响应时间阈值:.3f}s)")
        
        # 获取当前性能统计
        平均响应时间 = self.性能统计["平均响应时间"] if self.性能统计["平均响应时间"] > 0 else 0.1
        
        # 智能策略选择
        if 平均响应时间 > self._响应时间阈值 * 2:
            self._执行激进优化策略()
        elif 平均响应时间 > self._响应时间阈值 * 1.5:
            self._执行中等优化策略()
        else:
            self._执行保守优化策略()
    
    def _执行激进优化策略(self):
        """激进优化策略"""
        print("执行激进优化策略")
        # 大幅降低阈值
        self._响应时间阈值 = max(0.05, self._响应时间阈值 * 0.7)
        print(f"阈值调整为: {self._响应时间阈值:.3f}s")
    
    def _执行中等优化策略(self):
        """中等优化策略"""
        print("执行中等优化策略")
        # 中等降低阈值
        self._响应时间阈值 = max(0.06, self._响应时间阈值 * 0.85)
        print(f"阈值调整为: {self._响应时间阈值:.3f}s")
    
    def _执行保守优化策略(self):
        """保守优化策略"""
        print("执行保守优化策略")
        self._自适应调整响应时间阈值()
    
    def _自适应调整响应时间阈值(self):
        """自适应调整响应时间阈值（智能动态优化版）"""
        if len(self.性能统计["响应时间分布"]) >= 10:
            平均响应时间 = sum(self.性能统计["响应时间分布"][-10:]) / 10
            
            # 智能动态调整策略
            调整因子 = self._计算智能调整因子(平均响应时间)
            
            # 应用智能调整
            新阈值 = self._响应时间阈值 * 调整因子
            新阈值 = max(0.03, min(0.3, 新阈值))  # 限制在30ms-300ms范围内
            
            if abs(新阈值 - self._响应时间阈值) > 0.01:  # 变化超过10ms才调整
                self._响应时间阈值 = 新阈值
                print(f"智能调整响应阈值: {self._响应时间阈值:.3f}s (因子: {调整因子:.2f})")
    
    def _计算智能调整因子(self, 平均响应时间: float) -> float:
        """计算智能调整因子"""
        # 基础响应时间与阈值的比率
        比率 = 平均响应时间 / self._响应时间阈值
        
        # 智能调整逻辑
        if 比率 < 0.6:
            return 1.15  # 性能极好，提高15%
        elif 比率 < 0.8:
            return 1.08  # 性能良好，提高8%
        elif 比率 < 0.95:
            return 1.02  # 性能正常，小幅提高2%
        elif 比率 < 1.1:
            return 1.0   # 不变
        elif 比率 < 1.3:
            return 0.95  # 轻微超时，降低5%
        elif 比率 < 1.6:
            return 0.9   # 中度超时，降低10%
        else:
            return 0.8   # 严重超时，降低20%
    
    def _定期性能优化(self):
        """定期性能优化"""
        if self.执行次数 % (self._自适应调整间隔 * 2) == 0:
            # 获取性能数据
            性能数据 = self._分析性能趋势()
            
            # 根据性能趋势进行智能优化
            self._执行智能性能优化(性能数据)
    
    def _分析性能趋势(self) -> Dict[str, Any]:
        """分析性能趋势数据"""
        if len(self.性能统计["响应时间分布"]) < 20:
            return {"趋势": "数据不足", "稳定性": 0.0}
        
        # 分析最近20次响应时间
        最近数据 = self.性能统计["响应时间分布"][-20:]
        
        # 计算趋势（简单线性回归）
        趋势 = self._计算线性趋势(最近数据)
        
        # 计算稳定性（标准差）
        稳定性 = self._计算稳定性(最近数据)
        
        # 计算平均响应时间
        平均响应时间 = sum(最近数据) / len(最近数据)
        
        return {
            "趋势": 趋势,
            "稳定性": 稳定性,
            "平均响应时间": 平均响应时间,
            "样本数量": len(最近数据),
            "趋势强度": abs(趋势)
        }
    
    def _计算线性趋势(self, 数据: List[float]) -> float:
        """计算线性趋势"""
        n = len(数据)
        if n < 2:
            return 0.0
        
        # 计算斜率
        x = list(range(n))
        x_mean = sum(x) / n
        y_mean = sum(数据) / n
        
        分子 = sum((x[i] - x_mean) * (数据[i] - y_mean) for i in range(n))
        分母 = sum((x[i] - x_mean) ** 2 for i in range(n))
        
        if 分母 == 0:
            return 0.0
        
        return 分子 / 分母
    
    def _计算稳定性(self, 数据: List[float]) -> float:
        """计算数据稳定性（标准差）"""
        if len(数据) < 2:
            return 0.0
        
        平均值 = sum(数据) / len(数据)
        方差 = sum((x - 平均值) ** 2 for x in 数据) / len(数据)
        return 方差 ** 0.5
    
    def _执行智能性能优化(self, 性能数据: Dict[str, Any]):
        """执行智能性能优化"""
        if 性能数据["趋势"] == "数据不足":
            return
        
        趋势 = 性能数据["趋势"]
        稳定性 = 性能数据["稳定性"]
        
        # 智能优化策略
        if 趋势 > 0.005:  # 响应时间在上升
            if 稳定性 > 0.02:  # 波动较大
                print("执行稳定性优化")
            else:
                print("执行响应时间优化")
        elif 趋势 < -0.003:  # 响应时间在下降
            print("执行性能提升优化")
    
    def 获取优化状态(self) -> Dict[str, Any]:
        """获取优化状态信息"""
        if len(self.性能统计["响应时间分布"]) >= 10:
            性能数据 = self._分析性能趋势()
        else:
            性能数据 = {"趋势": "数据不足", "稳定性": 0.0}
        
        return {
            "当前阈值": self._响应时间阈值,
            "自适应间隔": self._自适应调整间隔,
            "连续超时次数": self._连续超时次数,
            "性能趋势": 性能数据,
            "响应时间分布样本数": len(self.性能统计["响应时间分布"]),
            "平均响应时间": self.性能统计["平均响应时间"] if self.执行次数 > 0 else 0.0,
            "最小响应时间": self.性能统计["最小响应时间"],
            "最大响应时间": self.性能统计["最大响应时间"]
        }
    
    def 运行测试(self, 测试次数: int = 50):
        """运行测试"""
        print("=" * 60)
        print("响应时间自适应调整功能测试")
        print("=" * 60)
        
        # 第一阶段：正常性能
        print("\n第一阶段：正常性能测试 (50-150ms)")
        for i in range(测试次数 // 2):
            响应时间 = random.uniform(0.05, 0.15)
            self.模拟执行循环(响应时间)
            
            if i % 10 == 0:
                状态 = self.获取优化状态()
                print(f"执行 {i:2d} 次 | 阈值: {状态['当前阈值']:.3f}s | 平均: {状态['平均响应时间']:.3f}s")
        
        # 第二阶段：性能下降
        print("\n第二阶段：性能下降测试 (150-300ms)")
        for i in range(测试次数 // 2):
            响应时间 = random.uniform(0.15, 0.3)
            self.模拟执行循环(响应时间)
            
            if i % 10 == 0:
                状态 = self.获取优化状态()
                print(f"执行 {i+测试次数//2:2d} 次 | 阈值: {状态['当前阈值']:.3f}s | 平均: {状态['平均响应时间']:.3f}s")
        
        # 最终状态报告
        print("\n" + "=" * 60)
        print("测试完成 - 最终状态报告")
        print("=" * 60)
        
        最终状态 = self.获取优化状态()
        for 键, 值 in 最终状态.items():
            if isinstance(值, dict):
                print(f"{键}:")
                for 子键, 子值 in 值.items():
                    print(f"  {子键}: {子值}")
            else:
                print(f"{键}: {值}")


def 主测试():
    """主测试函数"""
    # 创建测试器
    测试器 = 响应时间自适应测试器()
    
    # 运行测试
    测试器.运行测试(测试次数=50)
    
    # 测试智能调整因子
    print("\n" + "=" * 60)
    print("智能调整因子测试")
    print("=" * 60)
    
    阈值 = 0.1
    测试案例 = [
        (0.05, "性能极好"),
        (0.07, "性能良好"),
        (0.09, "性能正常"),
        (0.11, "接近阈值"),
        (0.13, "轻微超时"),
        (0.16, "中度超时"),
        (0.25, "严重超时")
    ]
    
    for 响应时间, 描述 in 测试案例:
        比率 = 响应时间 / 阈值
        调整因子 = 测试器._计算智能调整因子(响应时间)
        新阈值 = 阈值 * 调整因子
        print(f"响应时间: {响应时间:.3f}s ({描述}) | 比率: {比率:.2f} | 调整因子: {调整因子:.2f} | 新阈值: {新阈值:.3f}s")


if __name__ == "__main__":
    主测试()
"""
技能循环引擎 - 主引擎入口（重构版）
基于依赖注入和策略模式的现代化架构
集成安全监控、异常隔离和性能优化
"""
import time
import threading
from typing import Dict, Any, Optional, List
from config.配置管理器 import 配置管理器
from core.技能状态检测器 import 技能状态检测器
from core.目标选择器 import 目标选择器
from core.状态监测器 import 状态监测器
from core.依赖容器 import 容器工厂, 配置提供器接口
from core.策略接口 import 循环模式, 策略上下文, 策略管理器
from interface.按键操作接口 import 按键操作接口
from interface.图像获取接口 import 图像获取接口
from utils.性能监控 import 性能监控器, 监控操作
from utils.异常隔离 import 异常隔离器, 安全执行技能检测, 安全执行按键操作
from utils.权限控制 import 权限控制器, 需要权限
from utils.配置监听器 import 配置监听器
from utils.统一缓存管理器 import 注册全局缓存, 同步全局缓存策略, 全局缓存管理器
from utils.内存管理 import 全局内存监控器, 跟踪对象, 强制内存清理, 设置内存安全配置
from utils.自适应延迟 import 智能延迟


class 技能循环引擎:
    """
    重构后的技能循环引擎
    使用依赖注入和策略模式，支持可插拔架构
    """
    
    def __init__(self, 容器: Optional[Any] = None, 配置路径: str = "./config/", 
                 按键接口: Optional[按键操作接口] = None, 图像接口: Optional[图像获取接口] = None) -> None:
        """
        初始化技能循环引擎（依赖注入版本）
        
        参数:
            容器: 依赖容器实例，None则自动创建
            配置路径: 配置文件目录路径
            按键接口: 按键操作接口实例（可选，容器优先）
            图像接口: 图像获取接口实例（可选，容器优先）
        """
        # 运行状态控制
        self.running = False
        self.paused = False
        self.thread = None
        
        # 日志级别 (0=DEBUG, 1=INFO, 2=WARN, 3=ERROR)
        self.日志级别 = 1

        # 初始化依赖容器
        if 容器 is None:
            self.容器 = 容器工厂.创建默认容器(配置路径)
            
            # 注册默认依赖
            try:
                from interface.按键操作接口 import 按键操作接口
                from interface.幽灵盒子按键接口 import 幽灵盒子按键接口
                self.容器.注册实现(按键操作接口, 幽灵盒子按键接口)
                
                from interface.图像获取接口 import 图像获取接口
                from interface.Windows图像接口 import Windows图像接口
                self.容器.注册实现(图像获取接口, Windows图像接口)
            except ImportError as e:
                self._日志("警告", f"无法注册默认接口: {e}")
        else:
            self.容器 = 容器
        
        # 获取依赖实例
        self.配置提供器 = self.容器.获取实例(配置提供器接口)
        
        try:
            self.按键接口 = 按键接口 or self.容器.获取实例(按键操作接口)
        except Exception as e:
            self._日志("警告", f"未检测到硬件按键设备，按键功能将受限: {e}")
            self._日志("信息", "提示：请确保幽灵盒子硬件已连接")
            self.按键接口 = None
            
        try:
            self.图像接口 = 图像接口 or self.容器.获取实例(图像获取接口)
        except Exception as e:
            self._日志("信息", f"未找到图像接口，将禁用智能模式: {e}")
            self.图像接口 = None
        
        # 初始化配置管理器
        self.配置管理器 = 配置管理器(self.配置提供器.获取配置路径())
        
        # 判断使用模式
        self.使用智能模式 = self.图像接口 is not None
        
        # 初始化核心组件
        if self.使用智能模式:
            self.状态检测器 = 技能状态检测器()
            self.状态监测器 = 状态监测器(self.图像接口)
            self.策略管理器 = 策略管理器()
            self.检测区域 = self.配置管理器.获取检测区域()
            self.蓝条配置 = self.配置管理器.获取蓝条配置()
            self.目标状态配置 = self.配置管理器.获取目标状态配置() if hasattr(self.配置管理器, '获取目标状态配置') else {}
        else:
            # 简单模式下，从配置中获取技能序列
            self.技能序列 = self._获取技能序列()
            self.当前技能索引 = 0
        
        self.自动选人键值 = self.配置管理器.获取自动选人键值()
        self.选中最低血量键值 = self.配置管理器.获取选中最低血量键值() if hasattr(self.配置管理器, '获取选中最低血量键值') else 0
        self.目标选择器 = 目标选择器(self.按键接口, self.选中最低血量键值)
        
        # 当前模式
        self.当前模式 = 循环模式.默认循环
        
        # 状态追踪
        self.最后技能键值 = 0
        self.执行次数 = 0
        self.七情和合状态 = 0
        
        # 性能监控和安全控制
        self.性能监控器 = 性能监控器()
        self.异常隔离器 = 异常隔离器()
        self.权限控制器 = 权限控制器()
        self.配置监听器 = 配置监听器(self.配置提供器.获取配置路径())
        
        # 初始化异步功能
        # self.异步引擎 = 异步技能循环引擎() # 暂时注释，避免未定义引用
        # self.异步检测器 = 异步技能检测器() # 暂时注释，避免未定义引用
        
        # 初始化统一缓存管理器
        self.全局缓存管理器 = 全局缓存管理器
        
        # 注册技能状态检测器的缓存到全局缓存管理器
        if self.使用智能模式:
            注册全局缓存(self.状态检测器, "技能状态检测器")
        
        # 启动内存监控（优化：集成内存管理）
        self._启动内存监控()

        # 性能优化参数
        self._响应时间阈值 = 0.1  # 100ms阈值
        self._连续超时次数 = 0
        self._自适应调整间隔 = 10  # 每10次执行检查一次
        
        # 日志级别 (0=DEBUG, 1=INFO, 2=WARN, 3=ERROR)
        self.日志级别 = 1
    
    def _启动内存监控(self):
        """启动内存监控"""
        # 设置内存安全配置，确保不中断技能循环
        设置内存安全配置(
            清理时间窗口=0.05,  # 最大50ms清理时间
            清理优先级="低",     # 低优先级，避免影响主循环
            启用安全模式=True   # 启用安全模式
        )
        
        # 跟踪关键对象，防止内存泄漏
        跟踪对象("技能循环引擎", self)
        if hasattr(self, '状态检测器'):
            跟踪对象("技能状态检测器", self.状态检测器)
        if hasattr(self, '策略管理器'):
            跟踪对象("策略管理器", self.策略管理器)
        
        self._日志("信息", "内存监控已启动（安全模式）")
    
    def 获取安全配置(self) -> Dict[str, Any]:
        """获取内存安全配置信息"""
        from utils.内存管理 import 获取安全配置 as 获取内存安全配置
        return 获取内存安全配置()
    
    def 获取内存统计(self) -> Dict[str, Any]:
        """获取内存统计信息"""
        return 全局内存监控器.获取内存统计()
    
    def 强制内存清理(self):
        """强制执行内存清理"""
        强制内存清理()
        self._日志("信息", "已执行强制内存清理")
            
        # 同步缓存策略
        同步全局缓存策略()
        
        # 性能统计
        self.性能统计 = {
            "总执行时间": 0.0,
            "平均响应时间": 0.0,
            "成功率": 0.0,
            "最小响应时间": float('inf'),
            "最大响应时间": 0.0,
            "响应时间分布": []  # 记录最近100次响应时间
        }
        
        # 响应时间优化相关
        self._响应时间阈值 = 0.1  # 100ms阈值
        self._连续超时次数 = 0
        self._自适应调整间隔 = 10  # 每10次执行检查一次
        
        # 日志级别 (0=DEBUG, 1=INFO, 2=WARN, 3=ERROR)
        self.日志级别 = 1
    
    def _获取技能序列(self) -> List[int]:
        """
        简单模式下获取技能序列
        
        返回:
            list: 技能键值序列
        """
        技能字典 = self.配置管理器.技能字典
        
        # 根据优先级获取技能序列
        技能序列 = []
        
        # 默认技能优先级顺序
        for 技能名 in ["青川濯莲", "七情和合", "千枝绽蕊", "逐云寒蕊", 
                      "当归四逆", "银光照雪", "赤芍寒香", "绿野蔓生", "白芷含芳"]:
            技能配置 = 技能字典.get(技能名)
            if 技能配置 and "键值" in 技能配置:
                技能序列.append(技能配置["键值"])
        
        return 技能序列
    
    def 注册新策略(self, 策略实例: Any) -> None:
        """
        注册新的策略实现
        
        参数:
            策略实例: 实现技能策略接口的实例
        """
        if self.使用智能模式:
            self.策略管理器.注册策略(策略实例)
    
    def 获取可用策略(self) -> Dict[str, str]:
        """
        获取所有可用策略信息
        
        返回:
            dict: {策略名称: 策略描述}
        """
        if self.使用智能模式:
            return self.策略管理器.获取策略信息()
        return {}
    
    def 设置循环模式(self, 模式: 循环模式) -> None:
        """
        设置当前技能循环模式（支持枚举类型）
        
        参数:
            模式: 循环模式枚举值
        """
        if isinstance(模式, 循环模式):
            self.当前模式 = 模式
            
            # 设置策略（智能模式下）
            if self.使用智能模式:
                self.策略管理器.设置当前策略(模式)
        else:
            # 向后兼容：支持整型参数
            if 模式 in [1, 2]:
                self.当前模式 = 循环模式(模式)
                if self.使用智能模式:
                    self.策略管理器.设置当前策略(循环模式(模式))
            else:
                self.当前模式 = 循环模式.默认循环
    
    @需要权限("技能释放")
    @监控操作("执行技能循环")
    def 执行一次循环(self) -> bool:
        """
        执行一次完整的技能循环（安全优化版本）
        集成权限检查、性能监控和异常隔离
        
        返回:
            bool: 是否成功执行了技能释放
        """
        import time
        
        开始时间 = time.time()
        
        if self.当前模式 == 循环模式.默认循环:
            self._日志("调试", "技能循环未激活")
            return False
        
        # 使用异常隔离器安全执行
        成功, 结果, 错误信息 = self.异常隔离器.安全执行(self._执行循环逻辑, 开始时间)
        
        if not 成功:
            self._日志("错误", f"技能循环执行失败: {错误信息}")
            return False
        
        return 结果
    
    def _执行循环逻辑(self, 开始时间: float) -> bool:
        """
        实际的技能循环逻辑（安全隔离版本）
        优化响应时间：减少不必要的计算和IO操作
        """
        if self.使用智能模式:
            # 智能模式：使用策略模式进行智能决策
            策略 = self.策略管理器.获取当前策略()
            if not 策略:
                self._日志("警告", "未找到当前策略")
                return False
            
            # 创建策略上下文（优化：延迟加载，避免不必要的计算）
            上下文 = 策略上下文(
                技能状态检测器=self.状态检测器,
                图像获取接口=self.图像接口,
                状态监测器=self.状态监测器,
                技能字典=self.配置管理器.技能字典,
                气劲字典=self.配置管理器.气劲字典,
                蓝条配置=self.蓝条配置,
                检测区域=self.检测区域,
                七情和合状态=self.七情和合状态,
                目标状态配置=self.目标状态配置
            )
            
            # 使用策略推算技能（安全执行）
            技能键值 = self._安全推算技能(策略, 上下文)
        else:
            # 简单模式：按顺序循环释放技能
            if not self.技能序列:
                self._日志("警告", "技能序列为空")
                return False
            
            技能键值 = self.技能序列[self.当前技能索引]
            
            # 移动到下一个技能
            self.当前技能索引 = (self.当前技能索引 + 1) % len(self.技能序列)
        
        self.最后技能键值 = 技能键值
        
        # 如果有技能可释放
        if 技能键值 > 0:
            # 先执行自动选人（如果有配置）
            if self.自动选人键值 > 0:
                self._安全按下并释放("自动选人", self.自动选人键值)
            
            # 使用目标选择器选择最低血量队友 (如果配置了)
            if self.选中最低血量键值 > 0:
                self.目标选择器.选择最低血量队友()
                # 给一点时间让UI更新
                time.sleep(0.05)
            
            # 释放技能
            成功 = self._安全按下并释放("技能释放", 技能键值)
            
            if 成功:
                self.执行次数 += 1
                
                # 更新性能统计（优化：进一步减少计算频率）
                执行时间 = time.time() - 开始时间
                self.性能统计["总执行时间"] += 执行时间
                
                # 优化：每20次执行更新一次平均响应时间，大幅减少计算开销
                if self.执行次数 % 20 == 0:
                    self.性能统计["平均响应时间"] = self.性能统计["总执行时间"] / self.执行次数
                    self.性能统计["成功率"] = (self.执行次数 - 0) / self.执行次数
                
                # 执行响应时间优化（优化：仅在超时时执行）
                if 执行时间 > self._响应时间阈值 * 0.8:  # 超过80%阈值才优化
                    self._优化响应时间(执行时间)
                
                # 优化：仅在调试模式下记录详细耗时
                if self.日志级别 <= 0:  # 调试模式
                    self._日志("调试", f"成功释放技能: {技能键值}, 耗时: {执行时间:.3f}s")
                
                return True
        
        return False
    
    @安全执行技能检测
    def _安全推算技能(self, 策略, 上下文) -> int:
        """安全地推算技能"""
        return 策略.推算技能(上下文)
    
    def _优化响应时间(self, 执行时间: float):
        """
        响应时间优化逻辑（智能动态优化版）
        
        参数:
            执行时间: 本次执行的耗时
        """
        # 智能记录策略：根据性能状况动态调整记录频率
        if self.执行次数 % self._智能记录频率() == 0:
            if len(self.性能统计["响应时间分布"]) >= 100:
                self.性能统计["响应时间分布"].pop(0)
            self.性能统计["响应时间分布"].append(执行时间)
        
        # 智能更新最小最大响应时间
        if 执行时间 < self.性能统计["最小响应时间"] or 执行时间 > self.性能统计["最大响应时间"]:
            self.性能统计["最小响应时间"] = min(self.性能统计["最小响应时间"], 执行时间)
            self.性能统计["最大响应时间"] = max(self.性能统计["最大响应时间"], 执行时间)
        
        # 智能超时检测与自适应调整
        if 执行时间 > self._响应时间阈值:
            self._连续超时次数 += 1
            
            # 根据超时严重程度智能调整策略
            if self._连续超时次数 >= self._智能超时阈值():
                self._执行响应时间优化策略()
                self._连续超时次数 = 0
        else:
            self._连续超时次数 = 0
            
            # 性能良好时的智能优化
            if 执行时间 < self._响应时间阈值 * 0.6:
                self._性能良好优化()
        
        # 智能定期性能优化
        if self.执行次数 % self._智能优化频率() == 0:
            self._定期性能优化()
    
    def _智能记录频率(self) -> int:
        """智能记录频率计算"""
        if len(self.性能统计["响应时间分布"]) < 20:
            return 1  # 初期频繁记录
        
        # 根据稳定性调整记录频率
        稳定性 = self._计算稳定性(self.性能统计["响应时间分布"][-20:])
        if 稳定性 > 0.03:
            return 1  # 不稳定时频繁记录
        elif 稳定性 < 0.01:
            return 3  # 稳定时减少记录
        else:
            return 2  # 正常情况
    
    def _智能超时阈值(self) -> int:
        """智能超时阈值计算"""
        if len(self.性能统计["响应时间分布"]) < 10:
            return 3  # 初期使用默认阈值
        
        # 根据性能趋势调整超时阈值
        平均响应时间 = sum(self.性能统计["响应时间分布"][-10:]) / 10
        比率 = 平均响应时间 / self._响应时间阈值
        
        if 比率 > 1.5:
            return 2  # 性能差时敏感
        elif 比率 < 0.7:
            return 5  # 性能好时宽松
        else:
            return 3  # 正常情况
    
    def _智能优化频率(self) -> int:
        """智能优化频率计算"""
        if len(self.性能统计["响应时间分布"]) < 10:
            return self._自适应调整间隔 * 2  # 初期使用默认频率
        
        # 根据性能状况调整优化频率
        稳定性 = self._计算稳定性(self.性能统计["响应时间分布"][-10:])
        平均响应时间 = sum(self.性能统计["响应时间分布"][-10:]) / 10
        
        if 稳定性 > 0.04 or 平均响应时间 > self._响应时间阈值 * 0.9:
            return self._自适应调整间隔  # 性能差时频繁优化
        elif 稳定性 < 0.015 and 平均响应时间 < self._响应时间阈值 * 0.6:
            return self._自适应调整间隔 * 3  # 性能好时减少优化
        else:
            return self._自适应调整间隔 * 2  # 正常情况
    
    def _性能良好优化(self):
        """性能良好时的智能优化"""
        # 当性能良好时，可以适当放宽阈值以提高并行处理能力
        if self._响应时间阈值 < 0.15:
            # 小幅放宽阈值
            self._响应时间阈值 = min(0.2, self._响应时间阈值 * 1.05)
            self._日志("调试", f"性能良好，小幅放宽阈值至: {self._响应时间阈值:.3f}s")
    
    def _执行响应时间优化策略(self):
        """执行响应时间优化策略（智能自适应版）"""
        self._日志("信息", f"检测到响应时间过慢，执行智能优化策略")
        
        # 获取当前性能统计
        平均响应时间 = self.性能统计["平均响应时间"] if self.性能统计["平均响应时间"] > 0 else 0.1
        
        # 智能策略选择：根据响应时间严重程度选择不同策略
        if 平均响应时间 > self._响应时间阈值 * 2:
            # 严重超时：执行激进优化
            self._执行激进优化策略()
        elif 平均响应时间 > self._响应时间阈值 * 1.5:
            # 中度超时：执行中等优化
            self._执行中等优化策略()
        else:
            # 轻微超时：执行保守优化
            self._执行保守优化策略()
    
    def _执行激进优化策略(self):
        """激进优化策略：用于严重性能问题"""
        self._日志("警告", "执行激进优化策略")
        
        # 策略1：强制清理所有缓存
        try:
            if hasattr(self, '状态检测器') and hasattr(self.状态检测器, '清除缓存'):
                self.状态检测器.清除缓存()
                self._日志("调试", "已强制清理检测器缓存")
        except Exception as e:
            self._日志("警告", f"清理缓存失败: {e}")
        
        # 策略2：大幅降低日志级别
        self.日志级别 = 3  # 仅记录错误级别
        self._日志("信息", "日志级别设置为仅错误，大幅减少输出开销")
        
        # 策略3：强制内存清理
        try:
            self.强制内存清理()
            self._日志("调试", "已执行强制内存清理")
        except Exception as e:
            self._日志("警告", f"内存清理失败: {e}")
        
        # 策略4：临时禁用部分功能
        self._临时禁用非核心功能()
    
    def _执行中等优化策略(self):
        """中等优化策略：用于一般性能问题"""
        self._日志("信息", "执行中等优化策略")
        
        # 策略1：清理缓存
        try:
            if hasattr(self, '状态检测器') and hasattr(self.状态检测器, '清除缓存'):
                self.状态检测器.清除缓存()
                self._日志("调试", "已清理检测器缓存")
        except Exception as e:
            self._日志("警告", f"清理缓存失败: {e}")
        
        # 策略2：适度降低日志级别
        原日志级别 = self.日志级别
        if 原日志级别 < 2:
            self.日志级别 = 2  # 提升到警告级别
            self._日志("信息", "临时提升日志级别以减少输出开销")
        
        # 策略3：检查配置加载
        if hasattr(self, '配置监听器'):
            配置状态 = self.配置监听器.获取监听状态()
            if 配置状态.get("文件变更次数", 0) > 0:
                self._日志("信息", "检测到配置文件变更，重新加载配置")
                self.重新加载配置()
    
    def _执行保守优化策略(self):
        """保守优化策略：用于轻微性能问题"""
        self._日志("调试", "执行保守优化策略")
        
        # 策略1：仅清理部分缓存
        try:
            if hasattr(self, '状态检测器') and hasattr(self.状态检测器, '清除缓存'):
                self.状态检测器.清除缓存()
                self._日志("调试", "已清理检测器缓存")
        except Exception as e:
            self._日志("调试", f"清理缓存失败: {e}")
        
        # 策略2：轻微调整响应时间阈值
        self._自适应调整响应时间阈值()
    
    def _临时禁用非核心功能(self):
        """临时禁用非核心功能"""
        # 记录当前状态，以便恢复
        self._原配置监听状态 = hasattr(self, '配置监听器') and self.配置监听器.获取监听状态()
        
        # 临时禁用配置监听（如果启用）
        if hasattr(self, '配置监听器'):
            self.配置监听器.停止监听()
            self._日志("信息", "已临时禁用配置监听")
        
        # 设置恢复定时器（5分钟后恢复）
        import threading
        def 恢复功能():
            实际延迟 = 智能延迟(300)  # 5分钟自适应延迟
            self._日志("信息", f"智能恢复延迟: {实际延迟:.1f}秒")
            if hasattr(self, '配置监听器') and hasattr(self, '_原配置监听状态'):
                self.配置监听器.开始监听()
                self._日志("信息", "已恢复配置监听")
        
        threading.Thread(target=恢复功能, daemon=True).start()
    
    def _自适应调整响应时间阈值(self):
        """自适应调整响应时间阈值（智能动态优化版）"""
        if len(self.性能统计["响应时间分布"]) >= 10:
            平均响应时间 = sum(self.性能统计["响应时间分布"][-10:]) / 10
            
            # 智能动态调整策略
            调整因子 = self._计算智能调整因子(平均响应时间)
            
            # 应用智能调整
            新阈值 = self._响应时间阈值 * 调整因子
            新阈值 = max(0.03, min(0.3, 新阈值))  # 限制在30ms-300ms范围内
            
            if abs(新阈值 - self._响应时间阈值) > 0.01:  # 变化超过10ms才调整
                self._响应时间阈值 = 新阈值
                self._日志("调试", f"智能调整响应阈值: {self._响应时间阈值:.3f}s (因子: {调整因子:.2f})")
    
    def _计算智能调整因子(self, 平均响应时间: float) -> float:
        """计算智能调整因子"""
        # 基础响应时间与阈值的比率
        比率 = 平均响应时间 / self._响应时间阈值
        
        # 智能调整逻辑
        if 比率 < 0.6:
            # 性能极好，适当放宽阈值
            return 1.15  # 提高15%
        elif 比率 < 0.8:
            # 性能良好，小幅放宽
            return 1.08  # 提高8%
        elif 比率 < 0.95:
            # 性能正常，保持稳定
            return 1.02  # 小幅提高2%
        elif 比率 < 1.1:
            # 接近阈值，保持稳定
            return 1.0   # 不变
        elif 比率 < 1.3:
            # 轻微超时，小幅收紧
            return 0.95  # 降低5%
        elif 比率 < 1.6:
            # 中度超时，中等收紧
            return 0.9   # 降低10%
        else:
            # 严重超时，大幅收紧
            return 0.8   # 降低20%
    
    def _定期性能优化(self):
        """定期性能优化（智能动态调整）"""
        if self.执行次数 % (self._自适应调整间隔 * 2) == 0:
            # 获取性能数据
            性能数据 = self._分析性能趋势()
            
            # 根据性能趋势进行智能优化
            self._执行智能性能优化(性能数据)
    
    def _分析性能趋势(self) -> Dict[str, Any]:
        """智能性能趋势分析（多维度分析）"""
        if len(self.性能统计["响应时间分布"]) < 10:
            return {"趋势": "数据不足", "稳定性": 0.0, "分析级别": "基础"}
        
        # 智能分析窗口大小
        样本数量 = min(len(self.性能统计["响应时间分布"]), 30)
        最近数据 = self.性能统计["响应时间分布"][-样本数量:]
        
        # 多维度分析
        趋势 = self._计算线性趋势(最近数据)
        稳定性 = self._计算稳定性(最近数据)
        平均响应时间 = sum(最近数据) / len(最近数据)
        波动性 = self._计算波动性(最近数据)
        趋势置信度 = self._计算趋势置信度(最近数据, 趋势)
        性能等级 = self._评估性能等级(平均响应时间, 稳定性)
        
        # 智能预测
        预测趋势 = self._预测未来趋势(最近数据, 趋势)
        
        return {
            "趋势": 趋势,
            "稳定性": 稳定性,
            "平均响应时间": 平均响应时间,
            "波动性": 波动性,
            "趋势置信度": 趋势置信度,
            "性能等级": 性能等级,
            "预测趋势": 预测趋势,
            "样本数量": len(最近数据),
            "趋势强度": abs(趋势),
            "分析级别": "智能"
        }
    
    def _计算波动性(self, 数据: List[float]) -> float:
        """计算数据波动性（变异系数）"""
        if len(数据) < 2:
            return 0.0
        
        平均值 = sum(数据) / len(数据)
        if 平均值 == 0:
            return 0.0
        
        标准差 = self._计算稳定性(数据)
        return 标准差 / 平均值  # 变异系数
    
    def _计算趋势置信度(self, 数据: List[float], 趋势: float) -> float:
        """计算趋势置信度（R²决定系数）"""
        if len(数据) < 3:
            return 0.0
        
        # 计算总平方和
        y_mean = sum(数据) / len(数据)
        sst = sum((y - y_mean) ** 2 for y in 数据)
        
        if sst == 0:
            return 0.0
        
        # 计算回归平方和
        x = list(range(len(数据)))
        x_mean = sum(x) / len(x)
        
        # 预测值
        y_pred = [y_mean + 趋势 * (xi - x_mean) for xi in x]
        ssr = sum((y_pred[i] - y_mean) ** 2 for i in range(len(数据)))
        
        # R²决定系数
        r_squared = ssr / sst
        return max(0.0, min(1.0, r_squared))  # 限制在0-1范围内
    
    def _评估性能等级(self, 平均响应时间: float, 稳定性: float) -> str:
        """评估性能等级"""
        if 平均响应时间 < self._响应时间阈值 * 0.6:
            if 稳定性 < 0.015:
                return "优秀"
            else:
                return "良好"
        elif 平均响应时间 < self._响应时间阈值 * 0.8:
            if 稳定性 < 0.02:
                return "良好"
            else:
                return "正常"
        elif 平均响应时间 < self._响应时间阈值:
            return "需要优化"
        else:
            return "需要紧急优化"
    
    def _预测未来趋势(self, 数据: List[float], 当前趋势: float) -> Dict[str, Any]:
        """预测未来趋势（简单移动平均预测）"""
        if len(数据) < 10:
            return {"预测值": 0.0, "置信度": 0.0, "趋势": "数据不足"}
        
        # 使用移动平均预测
        窗口大小 = min(5, len(数据) // 2)
        移动平均 = sum(数据[-窗口大小:]) / 窗口大小
        
        # 预测未来3个周期的值
        预测值 = 移动平均 + 当前趋势 * 3
        置信度 = min(0.9, self._计算趋势置信度(数据, 当前趋势))
        
        # 趋势方向判断
        if 当前趋势 > 0.001:
            趋势方向 = "上升"
        elif 当前趋势 < -0.001:
            趋势方向 = "下降"
        else:
            趋势方向 = "稳定"
        
        return {
            "预测值": 预测值,
            "置信度": 置信度,
            "趋势": 趋势方向,
            "移动平均窗口": 窗口大小
        }
    
    def _计算线性趋势(self, 数据: List[float]) -> float:
        """计算线性趋势（简单线性回归斜率）"""
        n = len(数据)
        if n < 2:
            return 0.0
        
        # 计算斜率
        x = list(range(n))
        x_mean = sum(x) / n
        y_mean = sum(数据) / n
        
        分子 = sum((x[i] - x_mean) * (数据[i] - y_mean) for i in range(n))
        分母 = sum((x[i] - x_mean) ** 2 for i in range(n))
        
        if 分母 == 0:
            return 0.0
        
        return 分子 / 分母
    
    def _计算稳定性(self, 数据: List[float]) -> float:
        """计算数据稳定性（标准差）"""
        if len(数据) < 2:
            return 0.0
        
        平均值 = sum(数据) / len(数据)
        方差 = sum((x - 平均值) ** 2 for x in 数据) / len(数据)
        return 方差 ** 0.5
    
    def _执行智能性能优化(self, 性能数据: Dict[str, Any]):
        """执行智能性能优化（多级策略选择）"""
        if 性能数据["趋势"] == "数据不足":
            return
        
        # 多维度性能评估
        性能评分 = self._计算性能评分(性能数据)
        优化级别 = self._确定优化级别(性能评分, 性能数据)
        
        # 根据优化级别执行相应策略
        if 优化级别 == "紧急":
            self._执行紧急优化(性能数据)
        elif 优化级别 == "重度":
            self._执行重度优化(性能数据)
        elif 优化级别 == "中度":
            self._执行中度优化(性能数据)
        elif 优化级别 == "轻度":
            self._执行轻度优化(性能数据)
        elif 优化级别 == "预防":
            self._执行预防性优化(性能数据)
        else:
            self._执行常规维护(性能数据)
    
    def _计算性能评分(self, 性能数据: Dict[str, Any]) -> float:
        """计算综合性能评分（0-100分）"""
        if 性能数据["趋势"] == "数据不足":
            return 0.0
        
        平均响应时间 = 性能数据["平均响应时间"]
        稳定性 = 性能数据["稳定性"]
        趋势 = 性能数据["趋势"]
        波动性 = 性能数据["波动性"]
        
        # 响应时间评分（越低越好）
        响应时间评分 = max(0.0, 100.0 - (平均响应时间 / self._响应时间阈值) * 100)
        
        # 稳定性评分（越高越好）
        稳定性评分 = max(0.0, 100.0 - (稳定性 / 0.05) * 100)
        
        # 趋势评分（负趋势好）
        if 趋势 < -0.002:
            趋势评分 = 90.0  # 下降趋势好
        elif 趋势 < 0.002:
            趋势评分 = 70.0  # 稳定
        else:
            趋势评分 = max(0.0, 60.0 - (趋势 / 0.01) * 50)  # 上升趋势差
        
        # 波动性评分
        波动性评分 = max(0.0, 100.0 - (波动性 / 0.5) * 100)
        
        # 综合评分（加权平均）
        综合评分 = (
            响应时间评分 * 0.4 +  # 响应时间权重40%
            稳定性评分 * 0.3 +   # 稳定性权重30%
            趋势评分 * 0.2 +     # 趋势权重20%
            波动性评分 * 0.1     # 波动性权重10%
        )
        
        return 综合评分
    
    def _确定优化级别(self, 性能评分: float, 性能数据: Dict[str, Any]) -> str:
        """确定优化级别"""
        平均响应时间 = 性能数据["平均响应时间"]
        趋势 = 性能数据["趋势"]
        
        # 紧急情况
        if 平均响应时间 > self._响应时间阈值 * 1.5 or 性能评分 < 30:
            return "紧急"
        
        # 重度优化
        if 平均响应时间 > self._响应时间阈值 or 性能评分 < 50:
            return "重度"
        
        # 中度优化
        if 平均响应时间 > self._响应时间阈值 * 0.8 or 性能评分 < 70:
            return "中度"
        
        # 轻度优化
        if 平均响应时间 > self._响应时间阈值 * 0.7 or 趋势 > 0.003:
            return "轻度"
        
        # 预防性优化
        if 性能评分 < 85:
            return "预防"
        
        return "常规"
    
    def _执行紧急优化(self, 性能数据: Dict[str, Any]):
        """紧急优化：系统性能严重问题"""
        self._日志("错误", "执行紧急性能优化")
        
        # 策略1：强制清理所有缓存
        self._强制清理所有缓存()
        
        # 策略2：大幅降低响应时间阈值
        self._响应时间阈值 = max(0.05, self._响应时间阈值 * 0.7)
        self._日志("警告", f"紧急降低阈值至: {self._响应时间阈值:.3f}s")
        
        # 策略3：临时禁用非核心功能
        self._临时禁用非核心功能()
        
        # 策略4：强制内存清理
        self.强制内存清理()
        
        # 策略5：重置自适应间隔
        self._自适应调整间隔 = 5
        
    def _执行重度优化(self, 性能数据: Dict[str, Any]):
        """重度优化：系统性能明显问题"""
        self._日志("警告", "执行重度性能优化")
        
        # 策略1：清理缓存
        self._清理缓存()
        
        # 策略2：降低响应时间阈值
        self._响应时间阈值 = max(0.06, self._响应时间阈值 * 0.85)
        self._日志("信息", f"降低阈值至: {self._响应时间阈值:.3f}s")
        
        # 策略3：保守缓存策略
        self._调整缓存策略("保守")
        
        # 策略4：减少自适应间隔
        self._自适应调整间隔 = max(5, self._自适应调整间隔 - 1)
        
    def _执行中度优化(self, 性能数据: Dict[str, Any]):
        """中度优化：系统性能一般问题"""
        self._日志("信息", "执行中度性能优化")
        
        # 策略1：部分清理缓存
        self._部分清理缓存()
        
        # 策略2：小幅调整阈值
        self._响应时间阈值 = max(0.07, self._响应时间阈值 * 0.95)
        self._日志("调试", f"小幅调整阈值至: {self._响应时间阈值:.3f}s")
        
        # 策略3：平衡缓存策略
        self._调整缓存策略("平衡")
        
    def _执行轻度优化(self, 性能数据: Dict[str, Any]):
        """轻度优化：轻微性能问题"""
        self._日志("调试", "执行轻度性能优化")
        
        # 策略1：自适应调整阈值
        self._自适应调整响应时间阈值()
        
        # 策略2：优化内存使用
        if 性能数据["平均响应时间"] > self._响应时间阈值 * 0.8:
            self.强制内存清理()
        
    def _执行预防性优化(self, 性能数据: Dict[str, Any]):
        """预防性优化：性能良好但可优化"""
        self._日志("调试", "执行预防性性能优化")
        
        # 策略1：轻微放宽阈值
        if self._响应时间阈值 < 0.15:
            self._响应时间阈值 = min(0.2, self._响应时间阈值 * 1.05)
            self._日志("调试", f"预防性放宽阈值至: {self._响应时间阈值:.3f}s")
        
        # 策略2：激进缓存策略
        self._调整缓存策略("激进")
        
        # 策略3：增加自适应间隔
        self._自适应调整间隔 = min(20, self._自适应调整间隔 + 1)
        
    def _执行常规维护(self, 性能数据: Dict[str, Any]):
        """常规维护：性能优秀"""
        # 无需特殊优化，只需保持当前状态
        pass
    
    def _强制清理所有缓存(self):
        """强制清理所有缓存"""
        if hasattr(self, '状态检测器') and hasattr(self.状态检测器, '清除缓存'):
            try:
                self.状态检测器.清除缓存()
                self._日志("信息", "已强制清理所有缓存")
            except Exception as e:
                self._日志("警告", f"强制清理缓存失败: {e}")
        
        # 清理全局缓存
        try:
            if hasattr(self, '强制内存清理'):
                self.强制内存清理()
        except Exception as e:
            self._日志("调试", f"全局内存清理失败: {e}")
    
    def _清理缓存(self):
        """清理缓存"""
        if hasattr(self, '状态检测器') and hasattr(self.状态检测器, '清除缓存'):
            try:
                self.状态检测器.清除缓存()
                self._日志("调试", "已清理缓存")
            except Exception as e:
                self._日志("警告", f"清理缓存失败: {e}")
    
    def _部分清理缓存(self):
        """部分清理缓存"""
        # 仅清理部分缓存，避免完全重置
        if hasattr(self, '状态检测器') and hasattr(self.状态检测器, '清除缓存'):
            try:
                # 模拟部分清理
                self.状态检测器.清除缓存()
                self._日志("调试", "已执行部分缓存清理")
            except Exception as e:
                self._日志("调试", f"部分缓存清理失败: {e}")
    
    def _调整缓存策略(self, 策略类型: str):
        """调整缓存策略（多模式支持）"""
        if not hasattr(self, '状态检测器') or not hasattr(self.状态检测器, '设置缓存配置'):
            return
            
        try:
            if 策略类型 == "紧急":
                # 紧急策略：最小化缓存，最大化实时性
                self.状态检测器.设置缓存配置(缓存有效期=0.01, 技能缓存有效期=0.02)
                self._日志("警告", "已应用紧急缓存策略")
            elif 策略类型 == "保守":
                # 保守策略：增加缓存有效期，减少IO操作
                self.状态检测器.设置缓存配置(缓存有效期=0.1, 技能缓存有效期=0.2)
                self._日志("调试", "已应用保守缓存策略")
            elif 策略类型 == "平衡":
                # 平衡策略：中等缓存有效期
                self.状态检测器.设置缓存配置(缓存有效期=0.05, 技能缓存有效期=0.1)
                self._日志("调试", "已应用平衡缓存策略")
            elif 策略类型 == "激进":
                # 激进策略：减少缓存有效期，提高实时性
                self.状态检测器.设置缓存配置(缓存有效期=0.02, 技能缓存有效期=0.05)
                self._日志("调试", "已应用激进缓存策略")
            elif 策略类型 == "智能":
                # 智能策略：根据性能数据动态调整
                缓存配置 = self._计算智能缓存配置()
                self.状态检测器.设置缓存配置(**缓存配置)
                self._日志("调试", "已应用智能缓存策略")
            else:
                # 默认使用平衡策略
                self.状态检测器.设置缓存配置(缓存有效期=0.05, 技能缓存有效期=0.1)
                self._日志("调试", "已应用默认缓存策略")
        except Exception as e:
            self._日志("警告", f"调整缓存策略失败: {e}")
    
    def _计算智能缓存配置(self) -> Dict[str, float]:
        """计算智能缓存配置"""
        if len(self.性能统计["响应时间分布"]) < 10:
            return {"缓存有效期": 0.05, "技能缓存有效期": 0.1}
        
        # 根据性能数据动态计算缓存配置
        平均响应时间 = sum(self.性能统计["响应时间分布"][-10:]) / 10
        稳定性 = self._计算稳定性(self.性能统计["响应时间分布"][-10:])
        
        # 响应时间因子
        if 平均响应时间 < self._响应时间阈值 * 0.6:
            响应时间因子 = 1.2  # 性能好，可以增加缓存
        elif 平均响应时间 < self._响应时间阈值 * 0.8:
            响应时间因子 = 1.0  # 正常
        else:
            响应时间因子 = 0.8  # 性能差，减少缓存
        
        # 稳定性因子
        if 稳定性 < 0.01:
            稳定性因子 = 1.3  # 稳定，增加缓存
        elif 稳定性 < 0.02:
            稳定性因子 = 1.0  # 正常
        else:
            稳定性因子 = 0.7  # 不稳定，减少缓存
        
        # 综合因子
        综合因子 = (响应时间因子 + 稳定性因子) / 2
        
        # 计算缓存配置
        基础缓存有效期 = 0.05
        基础技能缓存有效期 = 0.1
        
        缓存有效期 = max(0.01, min(0.15, 基础缓存有效期 * 综合因子))
        技能缓存有效期 = max(0.02, min(0.3, 基础技能缓存有效期 * 综合因子))
        
        return {
            "缓存有效期": 缓存有效期,
            "技能缓存有效期": 技能缓存有效期
        }
    
    def 获取响应时间优化状态(self) -> Dict[str, Any]:
        """获取响应时间优化状态信息"""
        if len(self.性能统计["响应时间分布"]) >= 10:
            性能数据 = self._分析性能趋势()
        else:
            性能数据 = {"趋势": "数据不足", "稳定性": 0.0, "分析级别": "基础"}
        
        return {
            "当前阈值": self._响应时间阈值,
            "自适应调整间隔": self._自适应调整间隔,  # 修正属性名
            "连续超时次数": self._连续超时次数,
            "性能趋势": 性能数据,
            "响应时间分布样本数": len(self.性能统计["响应时间分布"]),
            "平均响应时间": self.性能统计["平均响应时间"] if self.执行次数 > 0 else 0.0,
            "最小响应时间": self.性能统计["最小响应时间"],
            "最大响应时间": self.性能统计["最大响应时间"]
        }
    
    @安全执行按键操作
    def _安全按下并释放(self, 操作名称: str, 键值: int) -> bool:
        """安全地按下并释放按键"""
        self._日志("信息", f"执行{操作名称}: {键值}")
        return self.按键接口.按下并释放(键值)
    
    def _日志(self, 级别: str, 消息: str):
        """
        分级日志记录
        
        参数:
            级别: 日志级别 (调试/信息/警告/错误)
            消息: 日志消息
        """
        级别映射 = {"调试": 0, "信息": 1, "警告": 2, "错误": 3}
        当前级别 = 级别映射.get(级别, 1)
        
        if 当前级别 >= self.日志级别:
            时间戳 = time.strftime("%Y-%m-%d %H:%M:%S")
            print(f"[{时间戳}] [{级别}] {消息}")
    
    def 设置日志级别(self, 级别: str):
        """
        设置日志级别
        
        参数:
            级别: 日志级别 (调试/信息/警告/错误)
        """
        级别映射 = {"调试": 0, "信息": 1, "警告": 2, "错误": 3}
        self.日志级别 = 级别映射.get(级别, 1)
        self._日志("信息", f"日志级别设置为: {级别}")
    
    def 开始配置监听(self):
        """开始监听配置文件变化"""
        # 监听关键配置文件
        self.配置监听器.添加监听("技能配置.json", self.重新加载配置)
        self.配置监听器.添加监听("技能模板配置.json", self.重新加载配置)
        self.配置监听器.添加监听("按键配置.json", self.重新加载配置)
        
        self.配置监听器.开始监听()
        self._日志("信息", "配置监听器已启动")
    
    def 停止配置监听(self):
        """停止监听配置文件变化"""
        self.配置监听器.停止监听()
        self._日志("信息", "配置监听器已停止")
    
    def 获取性能报告(self) -> Dict[str, Any]:
        """
        获取完整的性能报告
        
        返回:
            dict: 性能报告
        """
        基础统计 = {
            "执行次数": self.执行次数,
            "最后技能": self.最后技能键值,
            "当前模式": self.当前模式.name if hasattr(self.当前模式, 'name') else str(self.当前模式),
            "智能模式": self.使用智能模式
        }
        
        # 计算详细的响应时间统计
        if self.性能统计["响应时间分布"]:
            平均响应时间 = sum(self.性能统计["响应时间分布"]) / len(self.性能统计["响应时间分布"])
            响应时间分布 = {
                "样本数量": len(self.性能统计["响应时间分布"]),
                "平均值": 平均响应时间,
                "最小值": self.性能统计["最小响应时间"],
                "最大值": self.性能统计["最大响应时间"],
                "阈值": self._响应时间阈值,
                "连续超时": self._连续超时次数
            }
        else:
            响应时间分布 = {}
        
        性能报告 = self.性能监控器.生成性能报告()
        权限报告 = self.权限控制器.获取权限状态报告()
        
        return {
            "基础统计": 基础统计,
            "性能报告": 性能报告,
            "权限报告": 权限报告,
            "配置监听": self.配置监听器.获取监听状态(),
            "响应时间优化": 响应时间分布
        }
    
    def 检查权限状态(self) -> Dict[str, Any]:
        """
        检查当前权限状态
        
        返回:
            dict: 权限状态报告
        """
        return self.权限控制器.获取权限状态报告()
    
    def 重置性能统计(self):
        """重置所有性能统计"""
        self.性能监控器.重置统计()
        self.执行次数 = 0
        self.性能统计 = {
            "总执行时间": 0.0,
            "平均响应时间": 0.0,
            "成功率": 0.0
        }
        self._日志("信息", "性能统计已重置")
    
    def 设置七情和合状态(self, 状态: int):
        """
        设置七情和合状态
        
        参数:
            状态: 1=启用, 0=禁用
        """
        self.七情和合状态 = 状态
    
    def 获取当前状态(self) -> Dict[str, Any]:
        """
        获取当前引擎状态信息
        
        返回:
            dict: 包含引擎状态信息的字典
        """
        return {
            "当前模式": self.当前模式,
            "最后技能键值": self.最后技能键值,
            "执行次数": self.执行次数,
            "七情和合状态": self.七情和合状态,
            "检测区域": self.检测区域,
            "自动选人键值": self.自动选人键值
        }
    
    def 重新加载配置(self):
        """重新加载所有配置文件"""
        self.配置管理器.重新加载配置()
        
        # 更新配置信息
        self.检测区域 = self.配置管理器.获取检测区域()
        self.蓝条配置 = self.配置管理器.获取蓝条配置()
        self.自动选人键值 = self.配置管理器.获取自动选人键值()
    
    def 停止循环(self):
        """停止技能循环"""
        self.stop()
    
    def 释放所有按键(self):
        """释放所有当前按下的按键"""
        self.按键接口.释放所有按键()

    def start(self):
        """启动技能循环（后台线程）"""
        if not self.running:
            self.running = True
            self.paused = False
            self.thread = threading.Thread(target=self._run_loop, daemon=True)
            self.thread.start()
            self._日志("信息", "技能循环引擎已启动")

    def stop(self):
        """停止技能循环"""
        self.running = False
        self.paused = False
        if self.thread and self.thread.is_alive():
            self.thread.join(timeout=1.0)
        self.当前模式 = 0
        self.释放所有按键()
        self._日志("信息", "技能循环引擎已停止")

    def pause(self):
        """暂停/恢复技能循环"""
        self.paused = not self.paused
        状态 = "暂停" if self.paused else "恢复"
        self._日志("信息", f"技能循环引擎已{状态}")

    def get_running_status(self) -> Dict[str, Any]:
        """获取运行状态（UI适配）"""
        return {
            'running': self.running,
            'paused': self.paused,
            'mode': self.获取可用策略().get(self.当前模式, "未知模式") if self.使用智能模式 else "简单模式",
            'execution_count': self.执行次数,
            'avg_response_time': self.性能统计.get("平均响应时间", 0.0),
            'success_rate': self.性能统计.get("成功率", 0.0) * 100
        }

    def _run_loop(self):
        """后台循环线程"""
        while self.running:
            if not self.paused:
                try:
                    self.执行一次循环()
                except Exception as e:
                    self._日志("错误", f"循环异常: {e}")
                    time.sleep(1)
            else:
                time.sleep(0.1)
            
            # 避免CPU占用过高
            time.sleep(0.01)


# 示例适配器实现（用于演示）
class 示例按键适配器(按键操作接口):
    """示例按键适配器实现"""
    
    def 按下按键(self, 键值: int) -> bool:
        print(f"按下按键: {键值}")
        return True
    
    def 释放按键(self, 键值: int) -> bool:
        print(f"释放按键: {键值}")
        return True
    
    def 按下并释放(self, 键值: int) -> bool:
        print(f"按下并释放按键: {键值}")
        return True
    
    def 释放所有按键(self) -> bool:
        print("释放所有按键")
        return True


class 示例图像适配器(图像获取接口):
    """示例图像适配器实现"""
    
    def 获取屏幕区域(self, 区域: tuple):
        print(f"获取屏幕区域: {区域}")
        # 返回一个模拟的图像对象
        return MockImage()


class MockImage:
    """模拟图像对象"""
    
    def getpixel(self, 坐标):
        # 返回模拟的颜色值
        return (255, 255, 255)  # 白色


# 使用示例
if __name__ == "__main__":
    # 创建适配器实例
    按键适配器 = 示例按键适配器()
    图像适配器 = 示例图像适配器()
    
    # 创建引擎实例
    引擎 = 技能循环引擎(
        配置路径="./config/",
        按键接口=按键适配器,
        图像接口=图像适配器
    )
    
    # 设置循环模式
    引擎.设置循环模式(1)  # 默认循环模式
    
    # 执行一次循环
    引擎.执行一次循环()
    
    # 获取状态信息
    状态 = 引擎.获取当前状态()
    print(f"引擎状态: {状态}")

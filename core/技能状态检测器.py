"""
技能状态检测器（性能优化版）
基于颜色检测的技能状态判断逻辑，集成智能缓存和增量更新
"""
from typing import Dict, Any, Tuple, Optional, List
import time
from collections import defaultdict, deque
from utils.颜色判断工具 import 判断颜色是否在范围, 判断颜色是否超出范围


class 技能状态检测器:
    """技能状态检测器类（性能优化版）"""
    
    def __init__(self):
        """初始化检测器，添加性能优化功能"""
        # 智能缓存：缓存最近的颜色检测结果
        self._颜色缓存: Dict[Tuple[int, int], Tuple[Tuple[int, int, int], float]] = {}
        self._缓存有效期 = 0.05  # 50ms缓存有效期
        self._最大缓存大小 = 50
        
        # 检测结果缓存：缓存技能判断结果
        self._技能结果缓存: Dict[str, Tuple[int, float]] = {}
        self._技能缓存有效期 = 0.1  # 100ms技能缓存
        
        # 性能统计
        self._缓存命中次数 = 0
        self._缓存未命中次数 = 0
        self._总检测次数 = 0
        
        # 增量更新控制
        self._最后检测时间 = 0
        self._增量更新阈值 = 0.02  # 20ms内不重复检测
        
        # 智能缓存预热
        self._预热完成 = False
        self._预热阈值 = 0.85  # 缓存命中率目标
        self._预热样本数 = 20  # 预热样本数量
        self._预热样本记录 = deque(maxlen=self._预热样本数)
        
        # 自适应调整
        self._自适应调整间隔 = 50  # 每50次检测调整一次
    
    def 判断普通技能可用性(self, 图片, 技能配置: Dict[str, Any]) -> int:
        """
        判断普通技能是否可释放
        
        参数:
            图片: 图像对象（由适配器提供）
            技能配置: 技能配置字典
            
        返回:
            int: 技能键值（可释放时）或 0（不可释放时）
        """
        技能坐标值 = 技能配置.get("技能坐标值")
        技能颜色值 = 技能配置.get("技能颜色值")
        技能颜色波动值 = 技能配置.get("技能颜色波动值")
        
        # 获取图片中指定坐标的颜色值
        图片技能颜色值 = self._获取图片颜色(图片, 技能坐标值)
        
        if 判断颜色是否在范围(图片技能颜色值, 技能颜色值, 技能颜色波动值):
            return 0  # 技能不可释放
        else:
            return 技能配置.get("技能按键", {}).get("key", 0)
    
    def 判断气劲技能可用性(self, 图片, 气劲配置: Dict[str, Any]) -> int:
        """
        判断气劲相关技能是否处于激活状态
        
        参数:
            图片: 图像对象
            气劲配置: 气劲配置字典
            
        返回:
            int: 技能键值（激活时）或 0（未激活时）
        """
        气劲坐标值 = 气劲配置.get("技能坐标值")
        气劲颜色值 = 气劲配置.get("技能颜色值")
        气劲颜色波动值 = 气劲配置.get("技能颜色波动值")
        
        图片气劲颜色值 = self._获取图片颜色(图片, 气劲坐标值)
        
        if 判断颜色是否超出范围(图片气劲颜色值, 气劲颜色值, 气劲颜色波动值):
            return 气劲配置.get("技能按键", {}).get("key", 0)
        else:
            return 0
    
    def 判断气劲状态(self, 图片, 气劲配置: Dict[str, Any]) -> int:
        """
        判断气劲是否处于开启状态
        
        参数:
            图片: 图像对象
            气劲配置: 气劲配置字典
            
        返回:
            int: 1（开启）或 0（关闭）
        """
        气劲坐标值 = 气劲配置.get("技能坐标值")
        气劲颜色值 = 气劲配置.get("技能颜色值")
        气劲颜色波动值 = 气劲配置.get("技能颜色波动值")
        
        图片气劲颜色值 = self._获取图片颜色(图片, 气劲坐标值)
        
        if 判断颜色是否超出范围(图片气劲颜色值, 气劲颜色值, 气劲颜色波动值):
            return 1
        else:
            return 0
    
    def 判断蓝量状态(self, 图片, 蓝条配置: Dict[str, Any]) -> int:
        """
        判断当前游戏角色的蓝量情况
        
        参数:
            图片: 图像对象
            蓝条配置: 蓝条监控配置
            
        返回:
            int: 1（蓝量充足）或 0（蓝量不足）
        """
        蓝条坐标 = 蓝条配置.get("坐标")
        蓝条颜色 = 蓝条配置.get("颜色")
        蓝条颜色波动值 = 蓝条配置.get("颜色波动值")
        
        图片蓝条颜色值 = self._获取图片颜色(图片, 蓝条坐标)
        
        if 判断颜色是否在范围(图片蓝条颜色值, 蓝条颜色, 蓝条颜色波动值):
            return 0  # 蓝量小于30%
        else:
            return 1  # 蓝量大于等于30%
    
    def 判断素柯技能可用性(self, 图片, 技能配置: Dict[str, Any], 素柯配置: Dict[str, Any]) -> int:
        """
        判断素柯相关技能是否可释放
        
        参数:
            图片: 图像对象
            技能配置: 技能配置字典
            素柯配置: 素柯配置字典
            
        返回:
            int: 技能键值或状态码
        """
        素柯坐标值 = 素柯配置.get("技能坐标值")
        素柯颜色值 = 素柯配置.get("技能颜色值")
        素柯颜色波动值 = 素柯配置.get("技能颜色波动值")
        
        图片素柯颜色值 = self._获取图片颜色(图片, 素柯坐标值)
        
        # 先判断是否影响素柯
        if 判断颜色是否在范围(图片素柯颜色值, 素柯颜色值, 素柯颜色波动值):
            return -1  # 影响素柯
        
        # 特殊处理：白芷技能直接放行
        if 技能配置.get("技能按键", {}).get("key") == 103:  # 白芷含芳
            return 技能配置.get("技能按键", {}).get("key", 0)
        
        # 判断技能自身状态
        技能坐标值 = 技能配置.get("技能坐标值")
        技能颜色值 = 技能配置.get("技能颜色值")
        技能颜色波动值 = 技能配置.get("技能颜色波动值")
        
        图片技能颜色值 = self._获取图片颜色(图片, 技能坐标值)
        
        if 判断颜色是否在范围(图片技能颜色值, 技能颜色值, 技能颜色波动值):
            return 0  # 技能不可释放
        else:
            return 技能配置.get("技能按键", {}).get("key", 0)
    
    def _获取图片颜色(self, 图片, 坐标: list) -> tuple:
        """
        从图片中获取指定坐标的颜色值（优化版：带智能缓存）
        需要适配器确保图片对象支持getpixel方法
        
        参数:
            图片: 图像对象
            坐标: [x, y]坐标列表
            
        返回:
            tuple: RGB颜色值 (r, g, b)
        """
        # 增量更新检查：避免过于频繁的检测
        当前时间 = time.time()
        if 当前时间 - self._最后检测时间 < self._增量更新阈值:
            # 使用缓存结果（如果存在）
            缓存键 = (坐标[0], 坐标[1])
            if 缓存键 in self._颜色缓存:
                缓存颜色, 缓存时间 = self._颜色缓存[缓存键]
                if 当前时间 - 缓存时间 < self._缓存有效期:
                    self._缓存命中次数 += 1
                    return 缓存颜色
        
        self._最后检测时间 = 当前时间
        self._总检测次数 += 1
        
        try:
            # 实际获取颜色值
            颜色值 = 图片.getpixel((坐标[0], 坐标[1]))
            
            # 更新缓存
            缓存键 = (坐标[0], 坐标[1])
            self._颜色缓存[缓存键] = (颜色值, 当前时间)
            
            # 控制缓存大小
            if len(self._颜色缓存) > self._最大缓存大小:
                # 移除最旧的缓存项
                最旧键 = min(self._颜色缓存.keys(), key=lambda k: self._颜色缓存[k][1])
                del self._颜色缓存[最旧键]
            
            self._缓存未命中次数 += 1
            return 颜色值
            
        except AttributeError:
            # 如果适配器没有提供标准接口，需要适配器自行处理
            raise NotImplementedError("图像适配器需要实现getpixel方法或重写此方法")
    
    def 判断普通技能可用性_优化版(self, 图片, 技能配置: Dict[str, Any]) -> int:
        """
        判断普通技能是否可释放（优化版：带技能结果缓存）
        
        参数:
            图片: 图像对象
            技能配置: 技能配置字典
            
        返回:
            int: 技能键值（可释放时）或 0（不可释放时）
        """
        技能坐标值 = 技能配置.get("技能坐标值")
        技能颜色值 = 技能配置.get("技能颜色值")
        技能颜色波动值 = 技能配置.get("技能颜色波动值")
        
        # 检查技能结果缓存
        当前时间 = time.time()
        技能键 = f"普通技能_{技能坐标值}_{技能颜色值}_{技能颜色波动值}"
        
        if 技能键 in self._技能结果缓存:
            缓存结果, 缓存时间 = self._技能结果缓存[技能键]
            if 当前时间 - 缓存时间 < self._技能缓存有效期:
                return 缓存结果
        
        # 获取图片中指定坐标的颜色值（使用优化版）
        图片技能颜色值 = self._获取图片颜色(图片, 技能坐标值)
        
        if 判断颜色是否在范围(图片技能颜色值, 技能颜色值, 技能颜色波动值):
            结果 = 0  # 技能不可释放
        else:
            结果 = 技能配置.get("技能按键", {}).get("key", 0)
        
        # 更新技能结果缓存
        self._技能结果缓存[技能键] = (结果, 当前时间)
        
        return 结果
    
    def 清除缓存(self):
        """清除所有缓存"""
        self._颜色缓存.clear()
        self._技能结果缓存.clear()
        self._缓存命中次数 = 0
        self._缓存未命中次数 = 0
        self._总检测次数 = 0
        print("技能状态检测器缓存已清除")
    
    def 获取性能统计(self) -> Dict[str, Any]:
        """获取性能统计信息"""
        命中率 = self._缓存命中次数 / max(self._总检测次数, 1)
        
        return {
            "缓存命中率": f"{命中率:.2%}",
            "缓存命中次数": self._缓存命中次数,
            "缓存未命中次数": self._缓存未命中次数,
            "总检测次数": self._总检测次数,
            "颜色缓存大小": len(self._颜色缓存),
            "技能缓存大小": len(self._技能结果缓存),
            "缓存有效期": f"{self._缓存有效期}秒",
            "技能缓存有效期": f"{self._技能缓存有效期}秒"
        }
    
    def 设置缓存配置(self, 缓存有效期: float = None, 技能缓存有效期: float = None, 最大缓存大小: int = None):
        """设置缓存配置"""
        if 缓存有效期 is not None:
            self._缓存有效期 = 缓存有效期
        if 技能缓存有效期 is not None:
            self._技能缓存有效期 = 技能缓存有效期
        if 最大缓存大小 is not None:
            self._最大缓存大小 = 最大缓存大小
        
        print(f"缓存配置已更新：有效期={self._缓存有效期}s, 技能缓存={self._技能缓存有效期}s, 最大大小={self._最大缓存大小}")
    
    def _记录预热样本(self, 是否命中: bool):
        """记录预热样本"""
        if not self._预热完成:
            self._预热样本记录.append(是否命中)
            
            # 检查是否达到预热条件
            if len(self._预热样本记录) >= self._预热样本数:
                命中率 = sum(self._预热样本_record) / len(self._预热样本记录)
                if 命中率 >= self._预热阈值:
                    self._预热完成 = True
                    print(f"缓存预热完成，命中率: {命中率:.2%}")
    
    def _自适应调整缓存策略(self):
        """自适应调整缓存策略"""
        if self._总检测次数 % self._自适应调整间隔 == 0:
            命中率 = self._缓存命中次数 / max(self._总检测次数, 1)
            
            # 根据命中率调整缓存策略
            if 命中率 < 0.7:
                # 命中率低，缩短缓存有效期，提高响应速度
                self._缓存有效期 = max(0.02, self._缓存有效期 * 0.8)  # 最低20ms
                self._技能缓存有效期 = max(0.05, self._技能缓存有效期 * 0.8)  # 最低50ms
                print(f"自适应调整：命中率低({命中率:.2%})，缩短缓存有效期")
            elif 命中率 > 0.9:
                # 命中率高，延长缓存有效期，提高性能
                self._缓存有效期 = min(0.1, self._缓存有效期 * 1.2)  # 最高100ms
                self._技能缓存有效期 = min(0.2, self._技能缓存有效期 * 1.2)  # 最高200ms
                print(f"自适应调整：命中率高({命中率:.2%})，延长缓存有效期")
            
            # 重置统计
            self._缓存命中次数 = 0
            self._缓存未命中次数 = 0
            self._总检测次数 = 0
    
    def 预热缓存(self, 图片, 常用技能配置列表: List[Dict[str, Any]]):
        """预热缓存，提高初始性能"""
        print("开始缓存预热...")
        
        for 技能配置 in 常用技能配置列表:
            # 预热颜色缓存
            技能坐标值 = 技能配置.get("技能坐标值")
            if 技能坐标值:
                try:
                    self._获取图片颜色(图片, 技能坐标值)
                except:
                    pass
            
            # 预热技能结果缓存
            try:
                self.判断普通技能可用性_优化版(图片, 技能配置)
            except:
                pass
        
        print("缓存预热完成")
    
    def 获取缓存预热状态(self) -> Dict[str, Any]:
        """获取缓存预热状态"""
        预热进度 = len(self._预热样本记录) / self._预热样本数 if self._预热样本_num > 0 else 0
        
        if len(self._预热样本记录) > 0:
            当前命中率 = sum(self._预热样本记录) / len(self._预热样本记录)
        else:
            当前命中率 = 0
        
        return {
            "预热完成": self._预热完成,
            "预热进度": f"{预热进度:.2%}",
            "当前命中率": f"{当前命中率:.2%}",
            "预热样本数": len(self._预热样本记录),
            "目标样本数": self._预热样本数,
            "目标命中率": f"{self._预热阈值:.2%}"
        }